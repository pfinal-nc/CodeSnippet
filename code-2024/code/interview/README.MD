### 面试题收集

1. 分布式锁有那些实现方式?

   > 1.基于数据库实现分布式锁
   >
   > 2.基于缓存 redis等实现分布式锁
   >
   > 3.基于 zookeeper实现分布式锁

2. Mysql死锁产生的原因是什么?

   > 1.并发事务更新相同的数据集--当多个事务同时更新相同的数据集,并且使用了不同的顺序来获取锁时候,
   > 就可能产生死锁。例如,事务A先锁住数据集X,然后尝试获取数据集Y的锁,而事务B先锁住数据集Y，然后尝试获取数据集X的锁,
   这样就形成了死锁。
   >
   > 2.事务持有锁等待其他事务释放锁--当一个事务持有一个资源的锁,并且尝试获取另一个事务持有的资源的锁时,如果另一个事务也在等待当前事务持有的锁释放,
   > 就会导致死锁
   >
   > 3.锁粒度过大: 当锁的粒度过大时，多个事务同时访问相同的资源时会增加死锁的可能性, 例如:
   > 当一个事务锁定了整个表,而另一个事务也尝试锁定同一张表时,就可能产生死锁.
   >
   > 4.事务超时或者异常终止: 如果一个事务在持有所得过程中出现了超时或者异常终止,而此时该事务持有的锁没有被释放,就可能导致其他事务在等待该所的释放时出现死锁

>

3. 避免MySQL死锁的方法包括:

   > 1.使用合适的事务持有锁的时间,以减少死锁的可能性
   >
   > 2.尽量减少事务持有锁的时间,以缩短死锁发生的窗口
   >
   > 3.优化数据库设计, 避免长时间持有锁和锁的粒度过大。
   >
   > 4.监控和诊断数据库死锁, 并即使处理死锁事件
   >
   > 5.在应用层面设计良好的事务管理策略,以最小化死锁的可能性


4. Redis 哨兵的原理是什么？

   > redis 哨兵模式是 redis的高可用解决方案, 它为Redis 实例提供自动故障转移和主节点选举

   > 1. 监控, 在 redis 分布式系统中 多个 redis 节点组成一个主从复制(master-slave)结构, redis sentinel会监控所有节点的运行状态,
        包括主节点和从节点

   > 2. 自动故障检测: 当一个节点出现故障时，哨兵会立即感知到，并且根据预先配置的策略，自动地进行故障转移，将一个从节点提升为新的主节点，以保证系统的可用性

   > 3. 故障转移: 故障转移是 Redis Sentinel 的核心功能之一。当主节点失效时，哨兵会协调从节点中选举出一个新的主节点，然后通知客户端进行更新，使系统能够继续工作

   > 4. Redis Sentinel 还负责管理 Redis 分布式系统的配置信息。它可以监控配置变化，并在需要时自动地对配置进行更新，以确保系统的正确性

   > 5. 提供服务发现: 哨兵可以提供服务发现功能, 使客户能够动态地发现 redis 分布式系统中可用的节点, 并与之建立连接

5. API网关集群如何设计?

   > 1.负载均衡: 在API网关集群前面部署负载均衡器, 如 nginx, haproxy等, 以均衡流量分发到不同的API网关实例上.
   负载均衡器可以基于轮询,IP哈希, Least Connections等算法进行流量分发。

   > 2.高可用性: 每个API网关实例都应该是高可用的, 即使某个实例出现故障, 整个系统仍能继续工作。可以通过部署多个API
   网关实例,并使用负载均衡器进行故障转移来实现高可用性。

   > 3.扩展性: API网关集群应该能够根据需要动态地扩展和缩减实例数量, 可以采用自动化部署和容器化技术,
   如Docker和Kubernetes，来实现快速地扩展和收缩。

   > 4.安全性: API 网关应该提供安全功能,包括认证, 授权, API秘钥管理, 数据加密等.可以通过继成认证服务.使用HTTPS协议通信,
   实施访问控制策略等方式来提高安全性
   
   > 5.监控和日志： 在 API 网关集群中集成监控和日志功能，可以实时监控流量、性能指标、错误率等，并记录请求日志、错误日志等信息，以便及时发现和解决问题

   > 6.灰度发布： 为了降低发布新版本的风险，可以采用灰度发布策略，逐步将流量引导到新版本的 API 网关上，并根据反馈结果决定是否全面发布新版本

   > 7.容错和限流:  API 网关应该具备容错和限流的能力，能够应对突发流量和故障情况。可以通过实施断路器模式、限制并发连接数、实现请求重试等方式来增强容错性和限流能力。


6. swoole的event事件管理工作原理？

   > swoole 的事件管理机制是基于事件循环 event loop 实现的,其工作原理是:
   
   > 1. 事件循环: Swoole 的事件是基于事件循环模型,该模型在单个线程中循环监听各种事件(如I/O事件,定时器时间等) 并在事件发生时触发相应的回调函数进行处理.
   
   > 2. 异步非阻塞I/O: Swoole 使用异步非阻塞I/O模型.在进行网络通信时不会因为等待I/O操作而阻塞当前线程,从而能够高效地处理大量并发请求
   
   > 3. 事件注册与回调: 开发者可以通过 Swoole 提供的API 将事件注册到事件循环中.并指定相应的事件处理回调函数。例如，可以注册读取数据事件、写入数据事件、定时器事件等。
   
   > 4. 事件分发与调度: 当某个事件发生时, 事件循环会立即调用相应的注册回调函数进行处理. 例如: 当有客户端连接到服务器时,时间循环会触发连接事件, 并调用相应的连接回调函数进行处理

   > 5. 定时器管理: Swoole 提供了定时器功能，允许开发者注册定时器事件，定时执行某些操作。事件循环会在指定的时间间隔内触发定时器事件，并调用相应的回调函数
   
   > 6. 协程支持: Swoole 的事件管理机制与协程配合使用，可以实现异步编程方式下的同步代码编写。开发者可以在协程中调用阻塞 I/O 操作，而不会造成整个事件循环的阻塞。

   > swoole 的事件管理工作原理是基于事件循环模型实现的, 它通过异步非阻塞 I/O、事件注册与回调、事件分发与调度、定时器管理等机制实现了高效的并发处理能力，并且与协程配合使用，可以编写简洁清晰的异步代码。
   

7. Sql 语句性能优化常用策略
   
   > 1. 为 WHERE 及 ORDER BY 涉及的列上建立索引
      > 对查询进行优化,应尽量避免全表扫描, 首先应考虑在 where 及 order by 涉及的列上建立索引
   > 2. where 中使用默认值代替 null 应尽量 避免在where 子句中对字段进行 null 值判断, 创建表时 null是默认值, 但大多数时候应该使用 not null 或者使用一个特殊的值, 如 0,-1 作为默认值
      > 为啥建议 where 中使用 默认值代替 null 四个原因:
      > a. 并不是说使用了is null 或者 is not null 就会不走索引了, 这个跟mysql版本以及查询成本都有关;  
      > b. 如果mysql优化器发现, 走索引比不走索引成本还要高, 就会放弃索引, 这些条件 !=, <>, is null, is not null 经常被认为让索引失效
      > c. 其实是因为一般情况下, 查询的成本高, 优化器自动放弃索引的;
      > d. 如果把 null 值,换成默认值 很多时候让走索引成为可能,同时, 表达意思也相对清晰一点
   > 3. 慎用 != 或 <> 操作符
      > mysql 只有对一下操作符才使用索引: <, <=, =, >, >=, BETWEEN, IN, 以及某些时候的 LIKE.
      > 所以: 应尽量避免在 WHERE 子句中使用 != 或 <> 操作符, 会导致全表扫描
   
   > 4. 慎用 OR 来连接条件
      > 使用 or 可能会使用索引失效, 从而全表扫描;
      > 应用尽量避免在 where 子句中使用 or 来连接条件, 否则将导致引擎放弃使用 索引而进行全表扫描
      > 可以使用 UNION 合并查询: select id from t where num=10 union all select id from where num=20
      > 一个关键的问题是否用到索引。他们的速度只同是否使用索引有关, 如果查询需要用到联合索引, 用 union all 执行的效率更高. 多个 OR 的字句没有用到索引,改写成 union的形式再试图与索引匹配

   > 5. 慎用IN 和 NOT IN
      
     > IN和NOT IN 要慎用, 否则会导致全表扫描. 对于连续的数值. 能用 BETWEEN 就不要用 IN: select id from t where num between 1 and 3;
   
   > 6. 慎用 左模糊 like '%...'
   
     > 模糊查询, like很可能让索引失效。 
     > 比如: select id from t where name like‘%abc%’ select id from t where name like‘%abc’ 而select id from t where name like‘abc%’才用到索引
     > 所以: 首先尽量避免模糊查询, 如果必须使用, 不采用全模糊查询, 也应尽量采用右模糊查询, 即like ‘…%’，是会使用索引的； 左模糊like ‘%…’无法直接使用索引，但可以利用reverse + function index的形式，变化成 like ‘…%’； 全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎，比如 ElasticSearch。 备注：如果一定要用左模糊like ‘%…’检索， 一般建议 ElasticSearch+Hbase架构

   > 7. WHERE 条件使用参数会导致全表扫描. 比如: select id from t where num=@num
      
      > 因为SQL只有在运行时才会解析局部变量,但优化程序不能将访问计划的选择推迟到 运行时候
      > 它必须在编译时进行选择,然而,如果在编译时建立访问计划, 变量的值还是未知的, 因而无法作为所以选择的输入项.
      > 所以,可以改为强制查询使用索引: select id from t with(index(索引名)) where num=@num
    
   > 8. 用exists 代替 IN 是一个好的选择:
      
      > 很多时候用 exists 代替 in 是一个好的选择 select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)

   > 9. 索引并不是越多越好
      
     >  索引固然可以提高相应的 SELECT 效率, 但同时也降低了 INSERT 及 UPDATE 的效率
     >  因为 INSERT 或 UPDATE 时可能会重建索引, 所以怎样建索引需要慎重考虑,视情况而定
     >  一个表的索引数量最好不要超过 6 个, 若太多则应考虑一些不常用到的列上建的索引是否有必要

   > 10. 尽量使用数字型字段
      
     > 因为引擎在处理查询和连接时会逐个比较字符串中每一个字符;
     > 而对于数字型而言只需要比较一次就够了;
     > 字符会降低查询和连接的性能, 并会增加存储开销
     > 所以, 尽量 使用数字型字段, 若只含数值信息的字段尽量不要涉及未字符型 这会降低查询和连接的性能,并会增加存储开销
   
   > 11. 尽可能得使用  



